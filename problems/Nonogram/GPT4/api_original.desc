Reasoning:

1. Decision Variables:
   - The decision variables are the cells in the grid. Each cell can either be shaded (1) or not shaded (0).

2. Domains:
   - The domain of each cell is {0,1}.

3. Constraints:
   - The constraints are given by the sequences for each row and column. For each row and column, the sequence of shaded blocks must match the given sequence. 
   - The sequences are separated by at least one unshaded cell.

4. Objective Function:
   - This is a satisfaction problem, so there is no objective function.

5. Simplifications or Modeling Choices:
   - We can use a 2D array to represent the grid. Each element of the array represents a cell in the grid.
   - We can use a function to check if a sequence of shaded blocks in a row or column matches the given sequence. This function can be used to encode the constraints.

MiniZinc model:
```minizinc
include "globals.mzn";

% Define the size of the grid
int: n; % number of rows
int: m; % number of columns

% Define the sequences for each row and column
array[1..n] of set of int: row_sequences;
array[1..m] of set of int: col_sequences;

% Define the grid
array[1..n, 1..m] of var 0..1: grid;

% Define a function to check if a sequence of shaded blocks matches the given sequence
function var bool: check_sequence(array[int] of var int: sequence, set of int: given_sequence) =
  let {
    % Count the number of consecutive shaded cells
    array[int] of var int: counts = [ sum(i in index_set(sequence) where sequence[i] = 1) ];
    % Check if the counts match the given sequence
    constraint forall(i in index_set(given_sequence))(counts[i] = given_sequence[i]);
  } in
  true;

% Encode the constraints
constraint forall(i in 1..n)(check_sequence([grid[i,j] | j in 1..m], row_sequences[i]));
constraint forall(j in 1..m)(check_sequence([grid[i,j] | i in 1..n], col_sequences[j]));

solve satisfy;
```