### Reasoning

1. **Problem Analysis**: Nonograms involve a grid where each row and column has constraints specifying the sequence of consecutive shaded blocks. The goal is to find a grid assignment where the shaded cells in each row and column match the given block sequences in order, with at least one unshaded cell between blocks.

2. **Decision Variables**: Use a 2D Boolean array `grid` of size `R x C`, where `true` represents shaded and `false` unshaded.

3. **Domains**: The Boolean variables naturally have domains `{true, false}`.

4. **Constraints**:
   - For each row, the sequence of shaded cells must match the row's block constraints. This is enforced using the `regular` constraint with a DFA that models the regular expression for the block sequence.
   - Similarly for each column.
   - The DFA for a block sequence `[b1, b2, ..., bk]` is designed to accept the pattern: zero or more unshaded, then `b1` shaded, then one or more unshaded, then `b2` shaded, and so on, ending with zero or more unshaded. The DFA includes states for gaps and blocks, with a sink state for invalid transitions.

5. **Objective Function**: This is a satisfaction problem, so no objective function is needed.

6. **Modeling Choices**:
   - Use the `regular` constraint for its ability to encode sequence constraints via DFAs.
   - Map grid cells to integers: `1` for unshaded (`false`) and `2` for shaded (`true`).
   - Compute DFA parameters for each row and column based on their block lists, including state count `Q`, alphabet size `S=2`, transition matrix `d`, initial state `q0=1`, and accepting states `F`.
   - Handle empty block lists (all unshaded) naturally within the DFA.

7. **Simplifications**: The DFA construction ensures that all valid sequences are accepted, and invalid sequences lead to a non-accepting sink state.

### MiniZinc Model

```minizinc
% Nonogram Puzzle Model
% Parameters: grid dimensions and block constraints for rows and columns

int: R; % Number of rows
int: C; % Number of columns
array[1..R] of list of int: row_blocks; % Block sequences for each row
array[1..C] of list of int: col_blocks; % Block sequences for each column

% Decision variables: grid of booleans (true = shaded, false = unshaded)
array[1..R, 1..C] of var bool: grid;

% Constraints for each row
constraint forall(i in 1..R) (
    let {
        list of int: L = row_blocks[i],
        int: k = length(L),
        int: total_sum = sum(L), % Cumulative sum for k blocks
        % Compute cumulative sums for indices 0..k
        array[0..k] of int: cumul = [0] ++ [sum([L[j] | j in 1..i]) | i in 1..k],
        int: Q = 2 + k + total_sum, % Number of states including sink
        % Initialize transition matrix with sink state Q
        array[1..Q, 1..2] of int: d = array2d(1..Q, 1..2, [Q | _ in 1..2*Q]),
        % Sequence for the row: 1 for unshaded, 2 for shaded
        array[1..C] of var int: row_seq = [ if grid[i,j] then 2 else 1 endif | j in 1..C ]
    } in
    if k == 0 then
        % If no blocks, all cells must be unshaded (handled by DFA, but explicit for clarity)
        constraint forall(j in 1..C) (not grid[i,j])
    else
        % Build DFA transition matrix
        % Define gap states g_i for i=0..k
        forall(i in 0..k) (
            let {
                int: s_g = 1 + i + cumul[i] % State for g_i
            } in (
                d[s_g, 1] = s_g, % On unshaded (1), stay in g_i
                if i < k then
                    d[s_g, 2] = 1 + (i+1) + cumul[i] % On shaded (2), go to start of next block
                else
                    d[s_g, 2] = Q % On shaded after last block, go to sink
                endif
            )
        )
        /\
        % Define block states for each block i and position j
        forall(i in 1..k) (
            let {
                int: start_i = 1 + i + cumul[i-1] % Start state for block i
            } in
            forall(j in 1..L[i]) (
                let {
                    int: s = start_i + j - 1 % State for b_i_j
                } in (
                    % On unshaded (1)
                    if j == L[i] then
                        d[s, 1] = 1 + i + cumul[i] % Go to g_i after completing block
                    else
                        d[s, 1] = Q % Invalid, go to sink
                    endif
                    /\
                    % On shaded (2)
                    if j < L[i] then
                        d[s, 2] = s + 1 % Go to next state in block
                    else
                        d[s, 2] = Q % Invalid, go to sink
                    endif
                )
            )
        )
        /\
        % Apply regular constraint for the row
        regular(row_seq, Q, 2, d, 1, {1 + k + total_sum})
    endif
);

% Constraints for each column
constraint forall(j in 1..C) (
    let {
        list of int: L = col_blocks[j],
        int: k = length(L),
        int: total_sum = sum(L),
        array[0..k] of int: cumul = [0] ++ [sum([L[i] | i in 1..i]) | i in 1..k],
        int: Q = 2 + k + total_sum,
        array[1..Q, 1..2] of int: d = array2d(1..Q, 1..2, [Q | _ in 1..2*Q]),
        array[1..R] of var int: col_seq = [ if grid[i,j] then 2 else 1 endif | i in 1..R ]
    } in
    if k == 0 then
        constraint forall(i in 1..R) (not grid[i,j])
    else
        forall(i in 0..k) (
            let {
                int: s_g = 1 + i + cumul[i]
            } in (
                d[s_g, 1] = s_g,
                if i < k then
                    d[s_g, 2] = 1 + (i+1) + cumul[i]
                else
                    d[s_g, 2] = Q
                endif
            )
        )
        /\
        forall(i in 1..k) (
            let {
                int: start_i = 1 + i + cumul[i-1]
            } in
            forall(j in 1..L[i]) (
                let {
                    int: s = start_i + j - 1
                } in (
                    if j == L[i] then
                        d[s, 1] = 1 + i + cumul[i]
                    else
                        d[s, 1] = Q
                    endif
                    /\
                    if j < L[i] then
                        d[s, 2] = s + 1
                    else
                        d[s, 2] = Q
                    endif
                )
            )
        )
        /\
        regular(col_seq, Q, 2, d, 1, {1 + k + total_sum})
    endif
);

% Solve statement: satisfy the constraints
solve satisfy;

% Output: display the grid with '#' for shaded and '.' for unshaded
output [ if fix(grid[i,j]) then "#" else "." endif ++ if j == C then "\n" else "" endif | i in 1..R, j in 1..C ];
```

This model defines the constraints for each row and column using the `regular` constraint with dynamically computed DFAs based on the block sequences. The output formats the grid for easy visualization.