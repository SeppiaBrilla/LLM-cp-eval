**Reasoning:**

1. **Decision Variables**: We need to determine the position of each container on the deck. For each container, we need its bottom-left corner coordinates (x, y) since containers are rectangles positioned parallel to deck sides.

2. **Domains**: 
   - x-coordinates: from 0 to (deck_width - container_width) to ensure container fits within deck
   - y-coordinates: from 0 to (deck_length - container_length) to ensure container fits within deck

3. **Constraints**:
   - **Non-overlapping**: No two containers can occupy the same space on the deck
   - **Boundary constraints**: All containers must fit completely within the deck boundaries
   - **Separation constraints**: Containers of certain classes must maintain minimum distances from each other, either along deck (x-direction) or across deck (y-direction)

4. **Problem Type**: This is a constraint satisfaction problem (CSP) - we want to determine if a feasible placement exists, not optimize any objective.

5. **Modeling Choices**:
   - Use 2D coordinates for bottom-left corner of each container
   - Model non-overlapping using disjunctive constraints (either separated in x OR y direction)
   - Handle class-based separation constraints by checking distances between containers of specified classes
   - Use global constraint `diffn` for efficient non-overlapping if available, or explicit disjunctive constraints

**MiniZinc Model:**

```minizinc
% Supply Vessel Container Loading Problem
% Pack containers on deck without overlap and respecting separation constraints

% Parameters
int: n_containers;                    % Number of containers
int: deck_width;                      % Deck width
int: deck_length;                     % Deck length

array[1..n_containers] of int: width;    % Container widths
array[1..n_containers] of int: length;   % Container lengths  
array[1..n_containers] of int: class;    % Container classes

% Separation constraints data
int: n_separations;                   % Number of separation rules
array[1..n_separations] of int: class1;  % First class in separation rule
array[1..n_separations] of int: class2;  % Second class in separation rule
array[1..n_separations] of int: min_x_sep;  % Minimum separation along deck (x-direction)
array[1..n_separations] of int: min_y_sep;  % Minimum separation across deck (y-direction)

% Decision variables - bottom-left corner coordinates
array[1..n_containers] of var 0..deck_width: x;
array[1..n_containers] of var 0..deck_length: y;

% Constraints

% 1. Containers must fit within deck boundaries
constraint forall(i in 1..n_containers) (
    x[i] + width[i] <= deck_width /\
    y[i] + length[i] <= deck_length
);

% 2. Non-overlapping constraints
constraint forall(i, j in 1..n_containers where i < j) (
    x[i] + width[i] <= x[j] \/     % i is left of j
    x[j] + width[j] <= x[i] \/     % j is left of i  
    y[i] + length[i] <= y[j] \/    % i is below j
    y[j] + length[j] <= y[i]       % j is below i
);

% 3. Class-based separation constraints
constraint forall(s in 1..n_separations, i, j in 1..n_containers where i != j) (
    (class[i] = class1[s] /\ class[j] = class2[s]) \/
    (class[i] = class2[s] /\ class[j] = class1[s]) ->
    (
        % Either separated by minimum distance in x-direction
        (x[i] + width[i] + min_x_sep[s] <= x[j] \/ 
         x[j] + width[j] + min_x_sep[s] <= x[i]) \/
        % Or separated by minimum distance in y-direction  
        (y[i] + length[i] + min_y_sep[s] <= y[j] \/
         y[j] + length[j] + min_y_sep[s] <= y[i])
    )
);

% Solve as satisfaction problem
solve satisfy;

% Output
output [
    "Container positions:\n"
] ++
[
    "Container " ++ show(i) ++ " (class " ++ show(class[i]) ++ 
    "): x=" ++ show(x[i]) ++ ", y=" ++ show(y[i]) ++ 
    ", width=" ++ show(width[i]) ++ ", length=" ++ show(length[i]) ++ "\n"
    | i in 1..n_containers
];
```