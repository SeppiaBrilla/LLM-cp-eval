**Reasoning:**

1. **Decision Variables**: We need a 2D array of boolean variables representing whether each cell in the grid is shaded (1) or unshaded (0).

2. **Input Parameters**: 
   - Grid dimensions (rows and columns)
   - Row constraints: for each row, a sequence of block lengths
   - Column constraints: for each column, a sequence of block lengths

3. **Constraint Modeling**: For each row and column, we need to ensure that:
   - The shaded cells form exactly the specified number of blocks
   - Each block has exactly the specified length
   - Blocks are separated by at least one unshaded cell
   - All shaded cells belong to one of the specified blocks

4. **Key Constraint Approach**: For each row/column, we can model this by:
   - Identifying the start positions of each block
   - Ensuring blocks don't overlap and have proper gaps
   - Ensuring the total pattern matches the constraint sequence

5. **Domain Considerations**: 
   - Grid cells are binary (0 or 1)
   - Block start positions must be within valid ranges
   - Need to handle cases where constraint sequences are empty (no shaded cells)

6. **Modeling Strategy**: Use auxiliary variables for block start positions and enforce that the shaded pattern exactly matches the required block sequence.

**MiniZinc Model:**

```minizinc
% Nonogram Solver
% Parameters - these would be provided as data
int: rows;
int: cols;

% Maximum number of blocks in any row/column constraint
int: max_blocks;

% Row constraints: row_blocks[i,j] gives the length of the j-th block in row i
% 0 means no block (for padding when rows have different numbers of blocks)
array[1..rows, 1..max_blocks] of int: row_blocks;
array[1..rows] of int: row_num_blocks; % actual number of blocks in each row

% Column constraints
array[1..cols, 1..max_blocks] of int: col_blocks;
array[1..cols] of int: col_num_blocks; % actual number of blocks in each column

% Decision variables
array[1..rows, 1..cols] of var 0..1: grid;

% Auxiliary variables for block start positions
array[1..rows, 1..max_blocks] of var 1..cols: row_starts;
array[1..cols, 1..max_blocks] of var 1..rows: col_starts;

% Constraint: each row satisfies its block pattern
constraint forall(r in 1..rows) (
    if row_num_blocks[r] = 0 then
        % No blocks in this row - all cells must be 0
        forall(c in 1..cols) (grid[r,c] = 0)
    else
        % Ensure blocks are properly positioned and separated
        forall(b in 1..row_num_blocks[r]) (
            % Block b starts at row_starts[r,b] and has length row_blocks[r,b]
            row_starts[r,b] + row_blocks[r,b] - 1 <= cols /\
            % All cells in the block are shaded
            forall(offset in 0..row_blocks[r,b]-1) (
                grid[r, row_starts[r,b] + offset] = 1
            )
        ) /\
        % Blocks are ordered and separated
        forall(b in 1..row_num_blocks[r]-1) (
            row_starts[r,b] + row_blocks[r,b] < row_starts[r,b+1]
        ) /\
        % Cells before first block are unshaded
        forall(c in 1..row_starts[r,1]-1) (
            grid[r,c] = 0
        ) /\
        % Cells after last block are unshaded
        forall(c in row_starts[r,row_num_blocks[r]] + row_blocks[r,row_num_blocks[r]]..cols) (
            grid[r,c] = 0
        ) /\
        % Cells between blocks are unshaded
        forall(b in 1..row_num_blocks[r]-1) (
            forall(c in row_starts[r,b] + row_blocks[r,b]..row_starts[r,b+1]-1) (
                grid[r,c] = 0
            )
        )
    endif
);

% Constraint: each column satisfies its block pattern
constraint forall(c in 1..cols) (
    if col_num_blocks[c] = 0 then
        % No blocks in this column - all cells must be 0
        forall(r in 1..rows) (grid[r,c] = 0)
    else
        % Ensure blocks are properly positioned and separated
        forall(b in 1..col_num_blocks[c]) (
            % Block b starts at col_starts[c,b] and has length col_blocks[c,b]
            col_starts[c,b] + col_blocks[c,b] - 1 <= rows /\
            % All cells in the block are shaded
            forall(offset in 0..col_blocks[c,b]-1) (
                grid[col_starts[c,b] + offset, c] = 1
            )
        ) /\
        % Blocks are ordered and separated
        forall(b in 1..col_num_blocks[c]-1) (
            col_starts[c,b] + col_blocks[c,b] < col_starts[c,b+1]
        ) /\
        % Cells before first block are unshaded
        forall(r in 1..col_starts[c,1]-1) (
            grid[r,c] = 0
        ) /\
        % Cells after last block are unshaded
        forall(r in col_starts[c,col_num_blocks[c]] + col_blocks[c,col_num_blocks[c]]..rows) (
            grid[r,c] = 0
        ) /\
        % Cells between blocks are unshaded
        forall(b in 1..col_num_blocks[c]-1) (
            forall(r in col_starts[c,b] + col_blocks[c,b]..col_starts[c,b+1]-1) (
                grid[r,c] = 0
            )
        )
    endif
);

% This is a satisfaction problem - we just need to find a valid solution
solve satisfy;

% Output the solution
output [
    if c = 1 then "\n" else "" endif ++
    if grid[r,c] = 1 then "█" else "·" endif
    | r in 1..rows, c in 1..cols
] ++ ["\n"];
```