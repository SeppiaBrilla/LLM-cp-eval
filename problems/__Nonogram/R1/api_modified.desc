**Reasoning:**

1. **Problem Analysis**: The problem involves arranging square tiles in a grid where each cell is either blank (0) or filled with stone (1). The constraints are that each row and column must contain sequences of consecutive filled cells matching given block lengths, with at least one blank cell between blocks. The order of blocks is fixed.

2. **Key Elements**:
   - Grid size: Let `R` be the number of rows and `C` be the number of columns.
   - Decision variables: A 2D binary grid `grid[1..R, 1..C]` where `grid[i,j] = 1` if filled, `0` if blank.
   - Constraints: For each row and column, the sequences of filled cells must match the given block patterns with separations.

3. **Modeling Approach**:
   - Use auxiliary variables `start_row` and `end_row` for each row to represent the start and end columns of each block. Similarly, `start_col` and `end_col` for columns.
   - The number of blocks per row (and column) can vary, so compute the maximum number of blocks per row (`max_blocks_row`) and per column (`max_blocks_col`).
   - For each row `i` with `k_i` blocks:
     - Ensure block lengths: `end_row[i,j] - start_row[i,j] + 1 = row_clues[i][j]` for each block `j`.
     - Ensure separation: `end_row[i,j] + 1 < start_row[i,j+1]` for `j=1..k_i-1`.
     - Bounds: `start_row[i,1] >= 1` and `end_row[i,k_i] <= C`.
     - Link to grid: `grid[i,col] = 1` iff column `col` is within any block `j`.
   - Similarly for each column `j` with `k_j` blocks.

4. **Assumptions**:
   - The grid dimensions and clues are provided as parameters.
   - The model uses exists constraints to connect the grid to block positions, which is efficient for typical problem sizes.

**MiniZinc model:**
```minizinc
% Parameters
int: R; % Number of rows
int: C; % Number of columns
array[1..R] of list of int: row_clues; % Row clues: lists of block lengths
array[1..C] of list of int: col_clues; % Column clues: lists of block lengths

% Compute maximum number of blocks per row and column
int: max_blocks_row = max([length(row_clues[i]) | i in 1..R]);
int: max_blocks_col = max([length(col_clues[j]) | j in 1..C]);

% Decision variables
array[1..R, 1..C] of var 0..1: grid; % Grid: 1 for filled, 0 for blank
array[1..R, 1..max_blocks_row] of var 1..C: start_row; % Start column of each block in rows
array[1..R, 1..max_blocks_row] of var 1..C: end_row;   % End column of each block in rows
array[1..C, 1..max_blocks_col] of var 1..R: start_col; % Start row of each block in columns
array[1..C, 1..max_blocks_col] of var 1..R: end_col;   % End row of each block in columns

% Constraints for rows
constraint forall(i in 1..R) (
    let {
        int: k_i = length(row_clues[i]) % Number of blocks in row i
    } in
    if k_i > 0 then
        forall(j in 1..k_i) (
            end_row[i,j] - start_row[i,j] + 1 = row_clues[i][j] % Block length match
        )
        /\
        forall(j in 1..k_i-1) (
            end_row[i,j] + 1 < start_row[i,j+1] % At least one blank between blocks
        )
        /\
        start_row[i,1] >= 1 % First block starts at least at column 1
        /\
        end_row[i,k_i] <= C % Last block ends at most at column C
    else
        % If no blocks, the row must be all blanks (handled by grid constraint below)
        true
    endif
);

% Link grid to row blocks: grid[i,col] is 1 iff col is in some block
constraint forall(i in 1..R, col in 1..C) (
    let {
        int: k_i = length(row_clues[i])
    } in
    grid[i,col] = 1 <-> exists(j in 1..k_i) (
        start_row[i,j] <= col /\ col <= end_row[i,j]
    )
);

% Constraints for columns
constraint forall(j in 1..C) (
    let {
        int: k_j = length(col_clues[j]) % Number of blocks in column j
    } in
    if k_j > 0 then
        forall(i in 1..k_j) (
            end_col[j,i] - start_col[j,i] + 1 = col_clues[j][i] % Block length match
        )
        /\
        forall(i in 1..k_j-1) (
            end_col[j,i] + 1 < start_col[j,i+1] % At least one blank between blocks
        )
        /\
        start_col[j,1] >= 1 % First block starts at least at row 1
        /\
        end_col[j,k_j] <= R % Last block ends at most at row R
    else
        true
    endif
);

% Link grid to column blocks: grid[row,j] is 1 iff row is in some block
constraint forall(j in 1..C, row in 1..R) (
    let {
        int: k_j = length(col_clues[j])
    } in
    grid[row,j] = 1 <-> exists(i in 1..k_j) (
        start_col[j,i] <= row /\ row <= end_col[j,i]
    )
);

% Solve statement: satisfy all constraints
solve satisfy;

% Output: display the grid as a matrix
output [
    if j = 1 then "\n" else "" endif ++
    if fix(grid[i,j]) = 1 then "1 " else "0 " endif
    | i in 1..R, j in 1..C
];
```